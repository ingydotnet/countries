!yamlscript/v0

ns: schemays

dsl =::
  int-rng:: /^(-?\d+)?\.\.(-?\d+)?$/
  flt-rng:: /^(-?\d+\.\d+)?\.\.(-?\d+\.\d+)?$/
  type-ref:: /^\+(\w+(?:-\w+)*)$/
  regex:: /^\/(.*)\/$/

defn mk-int-rng(rng):
  m =: rng =~ dsl.int-rng
  m x y =: m
  when-not x || y:
    die: "Range must have start or end number"
  x =: x && x:N
  y =: y && y:N
  when x && y && (x >= y):
    die "$x is not less than $y"
  fun =:
    fn(f):
      fn(n):
        when-not n:int?:
          die: "$n is not an integer"
        when-not f(n):
          die: "$n is not in range $rng"
  cond:
    not(x): fun(\(_ <= y))
    not(y): fun(\(_ >= x))
    else:   fun(\(x <= _ <= y))

defn mk-flt-rng(rng):
  m =: rng =~ dsl.flt-rng
  m x y =: m
  when-not x || y:
    die: "Range must have start or end number"
  x =: x && x:N
  y =: y && y:N
  when x && y && (x >= y):
    die "$x is not less than $y"
  fun =:
    fn(f):
      fn(n):
        when-not f(n):
          die: "$n is not in range $rng"
  cond:
    not(x): fun(\(_ <= y))
    not(y): fun(\(_ >= x))
    else:   fun(\(x <= _ <= y))

defn mk-type-ref(ref):
  fn(x):
    name =: ref.subs(1)
    call(name x) ||:
      die: |
        Failed to validate type '$name' for:
        $x

defn mk-str-rgx(rgx):
  m =: rgx =~ dsl.regex
  m r =: m
  rs =: "^$r$"
  r =: qr(rs)
  fn(s):
    string?(s) ||:
      die: |
        Not a string:
        $s
    s =~ r ||:
      die: |
        String: "$s"
        Does not match: $rs

defn dsl-type(s):
  cond:
    s =~ dsl.int-rng: mk-int-rng(s)
    s =~ dsl.flt-rng: mk-flt-rng(s)
    s =~ dsl.type-ref: mk-type-ref(s)
    s =~ dsl.regex: mk-str-rgx(s)
    else: die("Bad schemays type spec:\ '$s'")

defn mktype(name fns):
  intern NS name:symbol:
    fn(val):
      each f fns:
        f(val) ||:
          die: |
            Failed type '$name' validation:
            $val
      =>: val

defn mktype-map(name pair):
  intern NS name:symbol:
    fn(map):
      when-not map?(map):
        die: |
          Failed type '$name' check - not a map:
          $map
      new =:
        loop [[key type] *pair] pair:seq, new map:
          new =:
            key opt =:
              re-opt =: /\ +\?$/
              if key =~ re-opt:
                -[key.replace(re-opt) true]
                 [key false]
            val =: new.$key
            type =: type:string?.if(type:dsl-type type)
            if opt:
              if val:nil?:
                then: new
                else:
                  type: val
                  dissoc new: key
              if val:nil?:
                die: |
                  Missing key '$key' in:
                  $map
                else:
                  type: val
                  dissoc new: key
          if pair.?:
            recur: pair new
            else: new
      when new.?:
        die: |
          Mapping has unknown keys:
          $(yaml/dump(new:keys):chomp)
      =>: map

defn mklist(name check):
  intern NS name:symbol:
    fn(vals):
      if vals:coll?:
        each val vals:
          call check: val
        else:
          die: "Failed $name. Not a list: $val"

defn mktypes(specs):
  each spec specs:
    ks =: spec:keys
    cond:
      ks.has?('must'): mktype(spec.name spec.must)
      ks.has?('pair'): mktype-map(spec.name spec.pair)
      ks.has?('list'): mklist(spec.name spec.list)
      else: die()

    key val =: spec:first
    mktype key: val
